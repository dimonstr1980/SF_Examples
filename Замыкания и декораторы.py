# Замыкания и декораторы

# Функции высшего порядка — в программировании это функция, принимающая в качестве
# аргументов другие функции или возвращающая другую функцию в качестве результата.

# Основная идея состоит в том, что функции имеют
# тот же статус, что и другие объекты данных.

# Мы можем передавать функции как параметры:

def my_func(inside_func):
    inside_func()
    
# Можем возвращать как результат:

def a():
    def b(): 
        pass
    return b
    
# Pass в Python это заглушка, то есть, допустим, у вас есть код, который вы планируете
# дописать, но хотите отложить это по каким-то причинам, или ещё не придумали, что будет
# в коде. Оператор pass ничего не делает. Фактически, это такая заглушка для объектов.
# Например, pass может помочь в ситуации, когда нужно прописать структуру скрипта.
# Его можно ставить в циклах, функциях, классах.

# Для лучшего понимания функций высшего порядка можно представить себе конвейер, который
# собирает других роботов. То есть некая техника, которая собирает другую технику.

# Сделаем функцию, которая будет выполнять принимаемую функцию дважды:

def twice_func(inside_func):
    """Функция, выполняющая дважды функцию принятую в качестве аргумента"""
    inside_func()
    inside_func()

def hello():
    print("Hello")
  
test = twice_func(hello)

# Видим, что после того, как мы передали функцию hello в качестве
# аргумента для функции twice_func, она выполнялась в ней дважды.

# Замыкание в программировании — это функция, в теле которой присутствуют
# ссылки на переменные, объявленные вне тела этой функции в окружающем коде
# и не являющиеся её аргументами.

# Вспомните нелокальную (nonlocal) область видимости,
# на этом принципе работает замыкание функций.

# Сделаем функцию, которая будет возвращать функцию,
# всегда прибавляющую одно и тоже число x:

def make_adder(x):
    def adder(n):
        return x + n # захват переменной "x" из nonlocal области
    return adder # возвращение функции в качестве результата
   
# То есть мы сделали конвейер, который будет нам прибавлять
# фиксированное число x к любому числу n (см. функции высших порядков).
# Тогда сделаем функцию, которая будет прибавлять число 5 к любому числу.

add_5 = make_adder(5)
print(add_5(10))  # 15
print(add_5(100))  # 105

# Определив функции высших порядков и замыкание функций, давайте
# переходить к теме декораторов, которая основывается на них.

# Декораторы предназначены для подключения любого дополнительного поведения
# к основной функции, называемой декорируемой функцией, которое может
# выполняться до, после или даже вместо основной функции.
# При этом исходный код декорируемой функции никак не затрагивается.

# В качестве дополнительного поведения может выступать подсчет времени выполнения
# функции, проверка дополнительных условий, разрешающих выполнение указанной функции.

# Ниже представлен простейший декоратор, который не выполняет никаких дополнительных действий.

def my_decorator(a_function_to_decorate):
    # Здесь мы определяем новую функцию - «обертку». Она нам нужна, чтобы выполнять
    # каждый раз при вызове оригинальной функции, а не только один раз
    def wrapper():
        # здесь поместим код, который будет выполняться до вызова, потом вызов
        # оригинальной функции, потом код после вызова
        print("Я буду выполнен до основного вызова!")
        
        result = a_function_to_decorate()  # не забываем вернуть значение исходной функции
        
        print("Я буду выполнен после основного вызова!")
        return result
    return wrapper
    
# Получаем что-то вроде этого:

def my_decorator(a_function_to_decorate):
    def my_function():
        print("Я - оборачиваемая функция!")
        return 0
        
    print(my_function())
        
    def wrapper():
        decorated_function = my_decorator(my_function)  # декорирование функции
        print(decorated_function())
        print("Я буду выполнен до основного вызова!")
        
        result = a_function_to_decorate()  # не забываем вернуть значение исходной функции
        
        print("Я буду выполнен после основного вызова!")
        return result
    return wrapper
    
# Видим, что задекорировав my_function, мы добавили к ней
# новый функционал, не меняя исходный код самой функции.

# Зачем это нужно? Например, декораторы могут замерять время
# выполнения функции, либо количество запусков конкретной функции,
# а также можно сохранять результаты вычисления (кеширование).

# Давайте попробуем замерить время выполнения системной функции
# для возведения числа в степень 2 и соответствующего оператора.

import time


def decorator_time(fn):
    def wrapper():
        print(f"Запустилась функция {fn}")
        t0 = time.time()
        result = fn()
        dt = time.time() - t0
        print(f"Функция выполнилась. Время: {dt:.10f}")
        return dt  # задекорированная функция будет возвращать время работы
    return wrapper


def pow_2():
    return 10000000 ** 2


def in_build_pow():
    return pow(10000000, 2)


pow_2 = decorator_time(pow_2)
in_build_pow = decorator_time(in_build_pow)

pow_2()
# Запустилась функция <function pow_2 at 0x7f938401b158>
# Функция выполнилась. Время: 0.0000011921

in_build_pow()
# Запустилась функция <function in_build_pow at 0x7f938401b620>
# Функция выполнилась. Время: 0.0000021458

# Чтобы замерить время, будем использовать модуль time, в котором есть
# функция time(), возвращающая текущее время. Зная время до начала выполнения
# и сразу после, можно вычислить время работы функции.

# Видим, что наша функция работает быстрее, но один раз это не показатель.
# Нужно выполнить серию запусков и найти среднее время, тогда можно делать какие-то выводы.

# Возьмите из предыдущего примера декорированные функции, которые возвращают время работы
# основной функции и найдите среднее время выполнения для 100 выполнений каждой функции.

import time

N = 100


def decorator_time(fn):
    def wrapper():
        t0 = time.time()
        result = fn()
        dt = time.time() - t0
        return dt
    return wrapper


def pow_2():
    return 10000000 ** 2


def in_build_pow():
    return pow(10000000, 2)


pow_2 = decorator_time(pow_2)
in_build_pow = decorator_time(in_build_pow)

mean_pow_2 = 0
mean_in_build_pow = 0
for _ in range(N):
    mean_pow_2 += pow_2()
    mean_in_build_pow += in_build_pow()

print(f"Функция {pow_2} выполнялась {N} раз. Среднее время: {mean_pow_2 / N:.10f}")
print(f"Функция {in_build_pow} выполнялась {N} раз. Среднее время: {mean_in_build_pow / 100:.10f}")

