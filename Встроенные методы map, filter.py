# Встроенные методы map, filter

# Функция map пришла из функционального программирования. Она позволяет применять некую
# функцию к каждому элементу итерируемого объекта (строки, списки, кортежи, словари).

# Вот псевдокод, по которому работает map. Псевдокод — компактный, зачастую неформальный,
# способ описания алгоритмов, использующий ключевые слова языков программирования, но
# опускающий несущественные для понимания алгоритма подробности и специфический синтаксис.

def map_(func, some_list):
    # some_list объект, над которым будет производиться преобразование
    # func функция, которая должна выполняться над каждым объектом
    outp = []
    for i in range(len(some_list)):
        outp.append(func(some_list[i]))
    return outp
    
# Чтобы не использовать такую конструкцию каждый раз, введена встроенная функция:
# map(function, iter1, iter2, ...), где
# iter1, iter2, ... — может быть 1 и более итерируемых объектов, однако на вход 
# функции должно приходить такое же количество аргументов.
# function — ссылка на функцию.

# Но особенность функции map в том, что она возвращает результат вычислений не сразу, а в виде
# итератора, который в дальнейшем производит «ленивые» вычисления. Чтобы получить список
# значений, нужно в явном виде привести к нужному типу либо воспользоваться циклом for:

# print(list(map(pow_, a_list)))  # [1, 4, 9]

# for i in map(pow_, a_list):
#   pass

#---------------------------------------------------------------------------------------

# Функция filter согласно своему названию фильтрует элементы итерируемого объекта.

# Она принимает на вход:

# - функцию, которая должна возвращать bool значение (True или False);
# - итерируемый объект, над которым будет производиться фильтрация
#   (в этом случае можно передать только один объект).
# Функция filter возвращает итератор с теми элементами из входящей
# последовательности, для которых функция вернула True.



def filter(func, cont):
    outp = []
    for x in cont: # проходим циклом по итерируемому объекту
        if func(x): # проверяем условие для каждого элемента
            outp.append(x) # если True, добавляем в новый список
    return outp

# Рассмотрим задание, где из заданного списка необходимо вывести только
# положительные элементы. (только четные элементы: return x % 2 == 0 # [-2, 0, 2])

def positive(x):
    return x > 0  # функция возвращает только True или False

result = filter(positive, [-2, -1, 0, 1, -3, 2, -3])

# Возвращается итератор, т.е. перечисляйте или приводите к списку
print(list(result))   # [1, 2]

# В каких случаях стоит использовать map и filter?

# Чаще всего генераторы списков более читаемы,
# чем map и filter, особенно в простых конструкциях.

# map + filter
some_list = [i - 10 for i in range(20)]
def pow2(x): return x**2
def positive(x): return x > 0

print(some_list)
print(list(map(pow2, filter(positive, some_list))))

# Тоже самое через list comprehension:
list_ = [i**2 for i in some_list if i > 0]
print(list_)

# Возникает вопрос, когда использовать map, а когда list comprehension?
# Как оговаривалось ранее, map работает по принципу ленивых вычислений,
# а list comprehension возвращает результат вычислений сразу.

# map(func, list1)  # итератор, но никаких вычислений не будет произведено
# list(map(...))  # только здесь появляется объект

# [func(i) for i in list1]  # сразу готовый объект
# [func(i) for i in list1] == list(map(func, list1))  # результат один и тот же

